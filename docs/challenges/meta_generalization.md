# meta_generalization
Meta-learning suffers from a gener- alization challenge across tasks analogous to the challenge of generalising across instances in conventional machine learning. There are three sub-challenges: (i) The first chal- lenge is fitting a meta-learner to a wide distribution of tasks p(T), which as we have seen is challenging for ex- isting methods [206], [207], [230], and may be partly due to conflicting gradients between tasks [285]. (ii) The second challenge is generalising from meta-train to novel meta- test tasks drawn from p(T). This is exacerbated because the number of tasks available for meta-training is typically low (much less than the number of instances available in conventional supervised learning), making it difficult to fit complex task distributions. Thus meta-learnersâ€™ biggest suc- cesses have thus far been within very similar task families. (iii) The third challenge is generalising to meta-test tasks drawn from a different distribution than the training tasks. This is inevitable in many potential practical applications of meta-learning, for example generalising few-shot visual learning from everyday training images of ImageNet to specialist domains such as medical images [208]. From the perspective of a learner, this is a meta-level generalization of the domain-shift problem, as observed in supervised learn- ing. Addressing these issues through meta-generalizations
of regularization, transfer learning, domain adaptation, and domain generalization are emerging directions [173]. Fur- thermore, we have yet to understand which kinds of meta- representations tend to generalize better under certain types of domain shifts. Another interesting direction could be investigating
how introducing yet another level of learning abstractions could affect generalization performance, that is, meta-meta- learning. By learning how to do meta-learning, perhaps we can find meta-optimizers that can generalize very strongly across a large variety of types and intensities of domain and even modality shifts. Of course computational costs would be exponentially larger.
<!-- REFERENCE -->
